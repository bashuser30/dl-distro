#!/usr/bin/env bash
#
# dl-distro - Bash script to download and verify ISOs with GnuPG and shasums.
#
# Copyright (C) 2023 bashuser30 <bashuser30 at mailbox dot org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -euo pipefail

# Downloads files listed in "$@" using wget; exits on failure.
# Usage: wget_file "$sig_file" "$sum_file"
wget_file() {
    for file in "$@"; do
        if ! wget -qc --show-progress "$url/$file"; then
            echo -e "\nError: Failed to download $file.\n"
            exit 1
        fi
    done
}

# Checks for the GPG key needed, fetches it if missing; exits on failure
# If $distro requires minisign, fetch the key; exit on failure
fetch_gpg_key() {
    [[ "$verify" == "false" ]] && return 0

    case "$minisign" in
        false)
            if ! gpg --list-keys "$gpg_key" &> /dev/null; then
                echo -e "\nFetching GPG key: $gpg_key\n"
                if ! gpg --keyserver keyserver.ubuntu.com --recv-keys "$gpg_key"; then
                    echo -e "\nError: Failed to fetch GPG key $gpg_key.\n"
                    exit 1
                else
                    echo
                fi
            fi
            ;;
        true)
            check_dependencies "minisign"

            minisign_file="$(mktemp --tmpdir="$download_path")"

            trap 'rm -f "$minisign_file"' EXIT

            echo -e "\nFetching Minisign key from: $gpg_key\n"
            if ! wget -qO- "$gpg_key" > "$minisign_file"; then
                echo -e "\nError: Failed to fetch minisign key from: $gpg_key\n"
                exit 1
            fi
            ;;
    esac
}

# GPG: Verifies the "$sig_file" itself or provided file "$1"; deletes files and exits on failure
# Minisign: Verifies signature using all required files; deletes files and exits on failure
# Usage: gpg_verify or gpg_verify "$sum_file"
gpg_verify() {
    [[ "$verify" == "false" ]] && return 0

    case "$minisign" in
        false)
            cmd=("gpg" "--verify" "$sig_file")

            [[ -n "${1:-}" ]] && cmd+=("$1")

            echo
            if ! "${cmd[@]}"; then
                echo -e "\nError: GPG verification failed.\n"
                rm -f "$iso_file" "$sig_file" "$sum_file"
                exit 1
            fi
            echo
            ;;
        true)
            echo
            if ! minisign -V -p "$minisign_file" -x "$sig_file" -m "$sum_file"; then
                echo -e "\nError: Minisign verification failed.\n"
                rm -rf "$iso_file" "$sig_file" "$sum_file"
                exit 1
            fi
            echo
            ;;
    esac
}

# Verifies a file using its checksum; deletes files and exits based on success/failure
checksum_verify() {
    echo
    if ! "$sum_algo" -c --ignore-missing "$sum_file" 2> /dev/null; then
        echo -e "\nError: $sum_algo verification failed.\n"
        rm -f "$iso_file" "$sig_file" "$sum_file"
        exit 1
    else
        rm -f "$sig_file" "$sum_file"
        echo -e "\n[dl-distro] Download and verification successful.\n"
        exit 0
    fi
}

handle_download_path() {
    if [[ "$download_path" != "$(pwd)" ]]; then
        mkdir -p "$download_path" && cd "$download_path" || exit 1
    fi
}

# Presents a list of options to the user and returns their selected choice
# Usage: selected_option="$(get_choice "option1" "option2" ...)"
# Example: If user selects "amd64", then selected_option="amd64"
get_choice() {
    options=("$@")
    num_options="${#options[@]}"

    while true; do
        echo >&2
        for i in "${!options[@]}"; do
            printf "   %d. %s\n" "$((i+1))" "${options[$i]}" >&2
        done
        echo >&2

        read -rp "Enter your choice (1-$num_options): " user_choice >&2

        if [[ "$user_choice" -ge 1 && "$user_choice" -le "$num_options" ]]; then
            printf "%s" "${options[$user_choice-1]}"
            return 0
        else
            echo -e "\nInvalid choice. Please choose a number 1 to $num_options." >&2
        fi
    done
}

# Fetches and assigns specific values from a JSON file to global variables
# Keys provided should match the sequence of variable assignments
# Usage: fetch_and_assign_values "key1" "key2" ...
# Example: fetch_and_assign_values "gpg_key" "netinst.amd64.url" ...
fetch_and_assign_values() {
    keys=("$@")

    # Create a single jq query string to fetch all values and remove the trailing comma and space
    jq_query="$(printf ".${distro}.%s, " "${keys[@]}")"
    jq_query="${jq_query%, }"

    # Fetch values using the jq query string into an array
    readarray -t values < <(jq -r "$jq_query" "$json_file")

    # Assign values to variables
    gpg_key="${values[0]}"
    url="${values[1]}"
    iso_file="${values[2]}"
    sig_file="${values[3]}"
    sum_file="${values[4]}"
    sum_algo="${values[5]}"
}

# Checks the iso, sig, and sum file for the chosen combination
wget_spider() {
    [[ "$spider" == "false" ]] && return 0

    for file in "$iso_file" "$sig_file" "$sum_file"; do

        [[ -z "$file" ]] && continue
        sleep 1

        if ! wget -nvc --spider "$url/$file"; then
            echo -e "\nError: Failed to download $file.\n"
            exit 1
        fi
    done

    exit 0
}

download_arch() {
    fetch_and_assign_values "gpg_key" "url" "iso_file" "sig_file" "sum_file" "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file" "$sum_file" "$iso_file"
    gpg_verify "$iso_file"
    checksum_verify
}

download_debian() {
    debian_type="$(get_choice "netinst" "live")"

    case "$debian_type" in
        "netinst")
            architecture="$(get_choice "amd64" "arm64" "armel" "armhf" "i386" "mips64el" "mipsel" "ppc64el" "s390x")"
            url_key="${debian_type}.${architecture}.url"
            iso_key="${debian_type}.${architecture}.iso_file"
            ;;
        "live")
            environment="$(get_choice "cinnamon" "gnome" "kde" "lxde" "lxqt" "mate" "standard" "xfce")"
            url_key="${debian_type}.url"
            iso_key="${debian_type}.${environment}.iso_file"
            ;;
    esac

    fetch_and_assign_values "gpg_key" "$url_key" "$iso_key" "sig_file" "sum_file" "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"
    wget_file "$iso_file"
    checksum_verify
}

download_fedora() {
    fedora_type="$(get_choice "everything" "server" "silverblue" "spins" "workstation")"

    case "$fedora_type" in
        everything|workstation)
            architecture="$(get_choice "x86_64" "aarch64")"
            url_key="${fedora_type}.${architecture}.url"
            iso_key="${fedora_type}.${architecture}.iso_file"
            sig_key="${fedora_type}.${architecture}.sig_file"
            sum_key="${fedora_type}.${architecture}.sum_file"
            ;;
        "server")
            architecture="$(get_choice "x86_64" "aarch64")"
            image_type="$(get_choice "standard" "vm")"
            url_key="${fedora_type}.${architecture}.${image_type}.url"
            sig_key="${fedora_type}.${architecture}.sig_file"
            sum_key="${fedora_type}.${architecture}.sum_file"

            if [[ "$image_type" == "standard" ]]; then
                install_method="$(get_choice "dvd" "netinst")"
                iso_key="${fedora_type}.${architecture}.${image_type}.${install_method}.iso_file"
            else
                iso_key="${fedora_type}.${architecture}.${image_type}.iso_file"
            fi
            ;;
        "silverblue")
            url_key="${fedora_type}.url"
            iso_key="${fedora_type}.iso_file"
            sig_key="${fedora_type}.sig_file"
            sum_key="${fedora_type}.sum_file"
            ;;
        "spins")
            environment="$(get_choice "budgie" "cinnamon" "kde" "lxde" "lxqt" "mate" "sugar" "sway" "xfce" "i3")"
            url_key="${fedora_type}.url"
            iso_key="${fedora_type}.${environment}.iso_file"
            sig_key="${fedora_type}.sig_file"
            sum_key="${fedora_type}.sum_file"
            ;;
    esac

    fetch_and_assign_values "gpg_key" "$url_key" "$iso_key" "$sig_key" "$sum_key" "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file"
    gpg_verify
    wget_file "$iso_file"
    checksum_verify
}

download_kali () {
    kali_type="$(get_choice "current" "weekly")"
    image_type="$(get_choice "live" "qemu" "virtualbox" "vmware" "hyperv" "installer" "netinst" "purple")"

    case "$image_type" in
        live|installer|netinst)
            architecture="$(get_choice "amd64" "arm64" "i386")"
            ;;
        purple|hyperv)
            architecture="amd64"
            ;;
        qemu|virtualbox|vmware)
            if [[ "$kali_type" == "weekly" ]]; then
                architecture="amd64"
            else
                architecture="$(get_choice "amd64" "i386")"
            fi
            ;;
    esac

    fetch_and_assign_values "gpg_key" \
                            "${kali_type}.url" \
                            "${kali_type}.${image_type}.${architecture}.iso_file" \
                            "sig_file" \
                            "sum_file" \
                            "sum_algo"

    if [[ "$kali_type" == "weekly" ]]; then
        # Fetch the week number from the URL for weekly builds
        html_content="$(wget -qO- "$url")"
        current_week_num="$(echo "$html_content" | grep -o 'W[0-9]\+' | sort -r | head -n1 | cut -c2-)"
        iso_file="${iso_file//\{current_week_num\}/$current_week_num}"

        # If the specified ISO is not available for the current week, default to the previous week's ISO
        if ! echo "$html_content" | grep -q "$iso_file"; then
            echo -e "\nNo new ISO for week: $current_week_num. Downloading previous week.\n"
            (( prev_week_num=current_week_num-1 ))
            iso_file="${iso_file//$current_week_num/$prev_week_num}"
        fi
    fi

    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"
    wget_file "$iso_file"
    checksum_verify
}

download_mint () {
    mint_type="$(get_choice "mint" "debian edition")"

    case "$mint_type" in
        "mint")
            environment="$(get_choice "cinnamon" "mate" "xfce" "edge")"
            url_key="${mint_type}.url"
            iso_key="${mint_type}.${environment}.iso_file"
            ;;
        "debian edition")
            architecture="$(get_choice "64-bit" "32-bit")"
            url_key="\"${mint_type}\".url"
            iso_key="\"${mint_type}\".\"${architecture}\".iso_file"
            ;;
    esac

    fetch_and_assign_values "gpg_key" "$url_key" "$iso_key" "sig_file" "sum_file" "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"
    wget_file "$iso_file"
    checksum_verify
}

download_opensuse() {
    opensuse_type="$(get_choice "leap" "tumbleweed")"
    image_type="$(get_choice "standard" "vm")"

    case "$image_type" in
        "standard")
            install_method="$(get_choice "dvd" "netinst")"

            if [[ "$opensuse_type" == "leap" ]]; then
                architecture="$(get_choice "x86_64" "aarch64" "ppc64le" "s390x")"
            else
                architecture="$(get_choice "x86_64" "i586" "aarch64" "ppc64le" "s390x" "ppc64")"
            fi

            prefix="${opensuse_type}.${image_type}.${install_method}.${architecture}"
            ;;
        "vm")
            vm_type="$(get_choice "kvm" "hyperv" "vmware" "cloud")"

            if [[ "$vm_type" == "vmware" ]]; then
                architecture="x86_64"
            else
                architecture="$(get_choice "x86_64" "aarch64")"
            fi

            prefix="${opensuse_type}.${image_type}.${vm_type}.${architecture}"
            ;;
    esac

    fetch_and_assign_values "gpg_key" \
                            "${prefix}.url" \
                            "${prefix}.iso_file" \
                            "${prefix}.sig_file" \
                            "${prefix}.sum_file" \
                            "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"

    # Ensures we download the filename located in the $sum_file
    read -r line < "$sum_file"
    iso_file="${line##* }"

    wget_file "$iso_file"
    checksum_verify
}

download_parrotos() {
    parrot_type="$(get_choice "security" "home" "hack the box" "architect" "raspberry pi")"

    case "$parrot_type" in
        security|home)
            image_type="$(get_choice "iso" "virtualbox" "utm")"
            iso_key="${parrot_type}.${image_type}.iso_file"
            ;;
        "hack the box")
            iso_key="\"${parrot_type}\".iso.iso_file"
            ;;
        "architect")
            architecture="$(get_choice "arm64" "amd64" "i386")"
            iso_key="${parrot_type}.${architecture}.iso_file"
            ;;
        "raspberry pi")
            image_type="$(get_choice "core" "home" "security")"
            architecture="$(get_choice "armhf" "arm64")"
            iso_key="\"${parrot_type}\".${image_type}.${architecture}.iso_file"

            if [[ "$image_type" == "security" && "$architecture" == "armhf" ]]; then
                echo -e "\nThis image is currently unavailable. It should be back next Parrot OS release.\n"
                exit
            fi
            ;;
    esac

    fetch_and_assign_values "gpg_key" "url" "$iso_key" "sig_file" "sum_file" "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file"
    gpg_verify
    wget_file "$iso_file"
    checksum_verify
}

download_tails() {
    tails_type="$(get_choice "usb" "dvd/vm")"

    fetch_and_assign_values "gpg_key" \
                            "url" \
                            "\"${tails_type}\".iso_file" \
                            "\"${tails_type}\".sig_file" \
                            "sum_file" \
                            "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file" "$iso_file"
    gpg_verify "$iso_file"
    rm -f "$sig_file"
    echo -e "\n[dl-distro] Download and GPG verification successful. Tails does not provide checksum files.\n"
}

download_ubuntu() {
    ubuntu_type="$(get_choice "current" "lts")"
    image_type="$(get_choice "desktop" "server")"

    fetch_and_assign_values "gpg_key" \
                            "${ubuntu_type}.url" \
                            "${ubuntu_type}.${image_type}.iso_file" \
                            "sig_file" \
                            "sum_file" \
                            "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"
    wget_file "$iso_file"
    checksum_verify
}

download_void() {
    minisign=true
    architecture="$(get_choice "x86_64" "i686" "arm" "arm platforms")"

    case "$architecture" in
        "x86_64")
            void_type="$(get_choice "base" "xfce")"

            if [[ "$void_type" == "base" ]]; then
                image_type="$(get_choice "live" "rootfs tarball")"
                lib_type="$(get_choice "glibc" "musl")"
            else
                image_type="live"
                lib_type="$(get_choice "glibc" "musl")"
            fi
            ;;
        "i686")
            void_type="$(get_choice "base" "xfce")"

            if [[ "$void_type" == "base" ]]; then
                image_type="$(get_choice "live" "rootfs tarball")"
                lib_type="glibc"
            else
                image_type="live"
                lib_type="glibc"
            fi
            ;;
        "arm")
            void_type="$(get_choice "armv6l" "armv7l" "aarch64")"
            image_type="rootfs tarball"
            lib_type="$(get_choice "glibc" "musl")"
            ;;
        "arm platforms")
            void_type="$(get_choice "rpi-armv6l" "rpi-armv7l" "rpi-aarch64")"
            image_type="$(get_choice "live" "rootfs tarball")"
            lib_type="$(get_choice "glibc" "musl")"
            ;;
    esac

    fetch_and_assign_values "gpg_key" \
                            "url" \
                            "\"${architecture}\".\"${void_type}\".\"${image_type}\".\"${lib_type}\".iso_file" \
                            "sig_file" \
                            "sum_file" \
                            "sum_algo"
    wget_spider
    handle_download_path
    fetch_gpg_key
    wget_file "$sig_file" "$sum_file"
    gpg_verify
    wget_file "$iso_file"
    checksum_verify
}

download_whonix() {
    whonix_type="$(get_choice "qemu" "virtualbox")"

    fetch_and_assign_values "${whonix_type}.gpg_key" \
                            "${whonix_type}.url" \
                            "${whonix_type}.iso_file" \
                            "${whonix_type}.sig_file" \
                            "${whonix_type}.sum_file" \
                            "sum_algo"
    wget_spider
    fetch_gpg_key
    handle_download_path
    wget_file "$sig_file" "$sum_file" "$iso_file"
    gpg_verify "$iso_file"
    checksum_verify
}

usage() {
    cat <<EOF
USAGE:
    dl-distro [OPTIONS] [DISTRO] [PATH]

OPTIONS:
    -h, --help        Display this usage message.
    -n, --noverify    Skip GPG key fetching and verification.
    -s, --spider      Use wget --spider to check if ISO exists without downloading it.

DISTROS:
    arch      opensuse    whonix
    debian    parrotos
    fedora    tails
    kali      ubuntu
    mint      void

EXAMPLES:
    dl-distro arch
    dl-distro arch /run/media/$USER/Ventoy
    dl-distro -s arch


EOF
}

check_dependencies() {
    missing_deps=()

    for cmd in "$@"; do
        command -v "$cmd" &> /dev/null || missing_deps+=("$cmd")
    done

    if [[ "${#missing_deps[@]}" -gt 0 ]]; then
        echo -e "\nPlease install: ${missing_deps[*]}.\n"
        exit 1
    else
        return 0
    fi
}

fetch_json() {
    json_paths=(
        "$HOME/.config/dl-distro/distro_data.json"
        "$(dirname "$0")/distro_data.json"
        "/usr/share/dl-distro/distro_data.json"
    )

    for path in "${json_paths[@]}"; do
        if [[ -f "$path" ]]; then
            json_file="$path"
            return
        fi
    done

    echo -e "\nError: distro_data.json not found in any of the expected locations.\n"
    for path in "${json_paths[@]}"; do
        echo " - $path"
    done
    echo

    exit 1
}

main() {
    fetch_json

    verify=true
    spider=false
    minisign=false

    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            -h|--help) usage; exit 0 ;;
            -n|--noverify) verify=false; shift ;;
            -s|--spider) spider=true; shift ;;
            -*) echo -e "\nError: Unknown option: $1\nUse -h for available options: dl-distro -h\n"; exit 1 ;;
            *) break ;;
        esac
    done

    if [[ "$verify" == "true" ]]; then
        check_dependencies "gpg" "jq" "wget"
    else
        check_dependencies "jq" "wget"
    fi

    distro="${1:-none}"
    download_path="${2:-$(pwd)}"

    if [[ "$distro" == "none" ]]; then
        echo -e "\nError: No distro provided.\nUse -h for available options and distros: dl-distro -h\n"
        exit 1
    fi

    # Call the requested $distro's download function
    if type download_"$distro" &> /dev/null; then
        download_"$distro"
    else
        echo -e "\nError: Invalid distro: $distro\nUse -h for available distros: dl-distro -h\n"
        exit 1
    fi
}

main "$@"
