#!/usr/bin/env bash
#
#    dl-distro - Bash script for downloading and verifying OS images.
#
#    Copyright (C) 2023-2024 bashuser30 <bashuser30@mailbox.org>
#
#    dl-distro is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    dl-distro is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program. If not, see <https://www.gnu.org/licenses/>.
#

set -euo pipefail

if [ "$(id -u)" -eq 0 ]; then
	printf "ERROR: Do not run as root.\n" >&2
	exit 1
fi

VERSION="v2.0.0"
DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/dl-distro"
CONF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/dl-distro"
JSON_DIR="$DATA_DIR/json"
GPG_DIR="$DATA_DIR/gpg"
MINISIGN_DIR="$DATA_DIR/minisign"
SIGNIFY_DIR="$DATA_DIR/signify"
CONF_FILE="$CONF_DIR/dl-distro.conf"
DEFAULT_DOWNLOAD_DIR="$PWD"
AUTO_UPDATE_ENABLED="false"
VERIFICATION_ENABLED="true"
SPIDER_MODE_ENABLED="false"
GREEN=$'\033[1;32m'
RED=$'\033[1;31m'
YELLOW=$'\033[1;33m'
BOLD=$'\033[1;37m'
NC=$'\033[0m'

declare -A DISTROS

DISTROS=(["AlmaLinux OS"]="alma"
         ["Alpine Linux"]="alpine"
         ["Arch Linux"]="arch"
         ["Debian"]="debian"
         ["Fedora Linux"]="fedora"
         ["GParted Live"]="gparted"
         ["Kali Linux"]="kali"
         ["Linux Mint"]="mint"
         ["NixOS"]="nixos"
         ["OpenBSD"]="openbsd"
         ["openSUSE"]="opensuse"
         ["ParrotOS"]="parrot"
         ["Qubes OS"]="qubes"
         ["Rocky Linux"]="rocky"
         ["Slackware Linux"]="slackware"
         ["Solus"]="solus"
         ["Tails"]="tails"
         ["Ubuntu"]="ubuntu"
         ["Void Linux"]="void"
         ["Whonix"]="whonix")

JSON_URLS=("https://codeberg.org/bashuser30/dl-distro/raw/branch/master/data.json"
           "https://gitlab.com/bashuser30/dl-distro/-/raw/master/data.json"
           "https://raw.githubusercontent.com/bashuser30/dl-distro/master/data.json")

JSON_PATHS=("$CONF_DIR/data.json"
            "$(dirname "$0")/data.json"
            "$JSON_DIR/data.json"
            "/usr/share/dl-distro/data.json"
            "/usr/local/share/dl-distro/data.json")

# shellcheck disable=SC1090
[ -f "$CONF_FILE" ] && source "$CONF_FILE"

print_message() { printf "%b%s%b\n" "$BOLD" "$1" "$NC"; }
print_warning() { printf "%bWARNING: %b%s%b\n" "$YELLOW" "$BOLD" "$1" "$NC" >&2; }
print_error() { printf "%bERROR: %b%s%b\n" "$RED" "$BOLD" "$1" "$NC" >&2; }
print_version() { printf "dl-distro %s\nCopyright (C) 2023-2024 bashuser30 <bashuser30@mailbox.org>\n" "$VERSION"; }

dependency_check()
{
	missing_deps=()

	for cmd in "$@"; do
		command -v "$cmd" &> /dev/null || missing_deps+=("$cmd")
	done

	if [ "${#missing_deps[@]}" -eq 0 ]; then
		return 0
	else
		print_error "Please install: ${RED}${missing_deps[*]}"
		exit 1
	fi
}

wget_file()
{
	local url

	for url in "$@"; do
		if ! wget -P "$DEFAULT_DOWNLOAD_DIR" -qc --show-progress "$url"; then
			print_error "Failed to download: ${RED}$url"
			exit 1
		fi
	done
}

wget_spider()
{
	[[ "$SPIDER_MODE_ENABLED" == "false" ]] && return 0

	local url

	for url in "$@"; do
		if ! wget -nvc --spider "$url"; then
			print_error "Spider failed for: ${RED}$url"
			exit 1
		fi
	done
    exit 0
}

fetch_gpg_key()
{
	[[ "$VERIFICATION_ENABLED" == "false" ]] && return 0

	dependency_check "gpg"

	[[ ! -d "$GPG_DIR" ]] && mkdir -p "$GPG_DIR"

	gpg_key="$(jq -r ".gpg_keys.$1" "$JSON_FILE")"
	gpg_dir_perms="$(stat -c "%a" "$GPG_DIR")"

	[[ "$gpg_dir_perms" != "700" ]] && chmod 700 "$GPG_DIR"

	if ! gpg --homedir "$GPG_DIR" --list-keys "$gpg_key" &> /dev/null; then
		print_message "Fetching GPG key..."

		if ! gpg --homedir "$GPG_DIR" --keyserver hkps://keyserver.ubuntu.com --recv-keys "$gpg_key" &> /dev/null; then
			print_error "Failed to fetch GPG key: ${RED}$gpg_key"
			exit 1
		fi
	fi
}

verify_gpg_signature()
{
	[[ "$VERIFICATION_ENABLED" == "false" ]] && return 0

	cd "$DEFAULT_DOWNLOAD_DIR" || exit 1

	if gpg --homedir "$GPG_DIR" --verify "$@" &> /dev/null; then
		print_message "GPG verification: ${GREEN}SUCCESS"
	else
		rm -f "$iso_file" "$sig_file" "$sum_file"
		print_error "GPG verification: ${RED}FAILED"
		exit 1
	fi
}

fetch_minisign_key()
{
	[[ "$VERIFICATION_ENABLED" == "false" ]] && return 0

	dependency_check "minisign"

	minisign_key_url="$(jq -r ".minisign_keys.$distro" "$JSON_FILE")"
	minisign_key="$(basename "$minisign_key_url")"

	if [[ ! -f "$MINISIGN_DIR/$minisign_key" ]]; then
		print_message "Fetching Minisign key..."

		if ! wget -P "$MINISIGN_DIR" -q "$minisign_key_url"; then
			print_error "Failed to fetch Minisign key: ${RED}$minisign_key_url"
			exit 1
		fi
	fi
}

verify_minisign_signature()
{
	[[ "$VERIFICATION_ENABLED" == "false" ]] && return 0

	cd "$DEFAULT_DOWNLOAD_DIR" || exit 1

	if minisign -Vp "$MINISIGN_DIR/$minisign_key" -x "$sig_file" -m "$sum_file" &> /dev/null; then
		print_message "Minisign verification: ${GREEN}SUCCESS"
	else
		rm -f "$sig_file" "$sum_file"
		print_error "Minisign verification: ${RED}FAILED"
		exit 1
	fi
}

fetch_signify_key()
{
	[[ "$VERIFICATION_ENABLED" == "false" ]] && return 0

	if [[ -f /etc/os-release ]]; then
		# shellcheck disable=SC1091
		source /etc/os-release
	else
		print_warning "/etc/os-release is missing."
		print_warning "This is to determine the package name signify uses."
		print_warning "Defaulting to: signify"
	fi

	if [[ "${ID:-}" == "debian" || "${ID_LIKE:-}" =~ debian ]]; then
		signify_name="signify-openbsd"
	else
		signify_name="signify"
	fi

	dependency_check "$signify_name"

	signify_key_url="$(jq -r ".signify_keys.$distro" "$JSON_FILE")"
	signify_key="$(basename "$signify_key_url")"

	if [[ ! -f "$SIGNIFY_DIR/$signify_key" ]]; then
		print_message "Fetching Signify key..."

		if ! wget -P "$SIGNIFY_DIR" -q "$signify_key_url"; then
			print_error "Failed to fetch Signify key: ${RED}$signify_key_url"
			exit 1
		fi
	fi
}

verify_signify_signature()
{
	[[ "$VERIFICATION_ENABLED" == "false" ]] && return 0

	cd "$DEFAULT_DOWNLOAD_DIR" || exit 1

	if "$signify_name" -Vp "$SIGNIFY_DIR/$signify_key" -x "$sig_file" -m "$sum_file" &> /dev/null; then
		print_message "Signify verification: ${GREEN}SUCCESS"
	else
		rm -f "$sig_file" "$sum_file"
		print_error "Signify verification: ${RED}FAILED"
		exit 1
	fi
}

verify_checksum()
{
	cd "$DEFAULT_DOWNLOAD_DIR" || exit 1

	sum_algo="$(jq -r ".sum_algos.$distro" "$JSON_FILE")"

	if "$sum_algo" -c --ignore-missing "$sum_file" &> /dev/null; then
		rm -f "$sig_file" "$sum_file"
		print_message "$sum_algo verification: ${GREEN}SUCCESS"
	else
		rm -f "$iso_file" "$sig_file" "$sum_file"
		print_error "$sum_algo verification: ${RED}FAILED"
		exit 1
	fi
}

download_alma()
{
	wget_spider "$url"/{"$iso_file","$sig_file"}

	if [[ "$traverse_path" == *"${distro}_8"* ]]; then
		fetch_gpg_key "${distro}_8"
	else
		fetch_gpg_key "${distro}_9"
	fi

	wget_file "$url/$sig_file"
	verify_gpg_signature "$sig_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_alpine()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

download_arch()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

download_debian()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_fedora()
{
	wget_spider "$url"/{"$iso_file","$sig_file"}

	if [[ "$traverse_path" == *"astronomy"* ]]; then
		fetch_gpg_key "${distro}_38"
	else
		fetch_gpg_key "${distro}_39"
	fi

	wget_file "$url/$sig_file"
	verify_gpg_signature "$sig_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_gparted()
{
	sig_sum_url="$(jq -r ".oddballs.gparted.sig_sum_url" "$JSON_FILE")"
	wget_spider "$url/$iso_file" "$sig_sum_url"/{"$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$sig_sum_url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_kali ()
{
	if [[ "$traverse_path" == *"weekly"* ]]; then
		html_content="$(wget -qO- "$url/")"
		current_week_num="$(grep -o 'W[0-9]\+' <<< "$html_content" | sort -r | head -n 1 | cut -c2-)"
		iso_file="${iso_file//\{current_week_num\}/$current_week_num}"

		if ! grep -qF "$iso_file" <<< "$html_content"; then
			print_warning "No new ISO for week: ${YELLOW}$current_week_num"
			print_warning "Downloading previous week."
			(( prev_week_num=current_week_num-1 ))
			iso_file="${iso_file//$current_week_num/$prev_week_num}"
		fi
	fi

	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_mint ()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_nixos()
{
	wget_spider "$url"/{"$iso_file","$sum_file"}
	wget_file "$url"/{"$sum_file","$iso_file"}
	cd "$DEFAULT_DOWNLOAD_DIR" || exit 1
	printf '\n' >> "$sum_file"
	read -r line < "$sum_file"
	new_iso_file="${line##* }"
	mv "$iso_file" "$new_iso_file"
	iso_file="$new_iso_file"
	verify_checksum
	print_message "NixOS does not provide signatures."
}

download_openbsd()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_signify_key
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_signify_signature
	wget_file "$url/$iso_file"
	verify_checksum
	IFS='.' read -ra path_parts <<< "$traverse_path"
	architecture="${path_parts[3]}"
	base_name="${iso_file%.*}"
	ext="${iso_file##*.}"
	mv "$iso_file" "${base_name}-${architecture}.${ext}"
}

download_opensuse()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	read -r line < "$sum_file"
	iso_file="${line##* }"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_parrot()
{
	wget_spider "$url"/{"$iso_file","$sig_file"}
	fetch_gpg_key "$distro"
	wget_file "$url/$sig_file"
	verify_gpg_signature "$sig_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_qubes()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url/$sum_file"
	verify_gpg_signature "$sum_file"
	wget_file "$url"/{"$sig_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

download_rocky()
{
	wget_spider "$url"/{"$iso_file","$sum_file"}
	wget_file "$url"/{"$sum_file","$iso_file"}
	verify_checksum
	print_message "Rocky Linux does not provide signatures."
}

download_slackware()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

download_solus()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_tails()
{
	wget_spider "$url"/{"$iso_file","$sig_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	rm -f "$sig_file"
	print_message "Tails does not provide checksums."
}

download_ubuntu()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	[[ "$traverse_path" == *"trusty"* ]] && fetch_gpg_key "${distro}_trusty"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_void()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_minisign_key
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_minisign_signature
	wget_file "$url/$iso_file"
	verify_checksum
}

download_whonix()
{
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}

	if [[ "$traverse_path" == *"qemu"* ]]; then
		fetch_gpg_key "${distro}_qemu"
	else
		fetch_gpg_key "${distro}_vbox"
	fi

	wget_file "$url"/{"$sig_file","$sum_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

toggle_auto_update()
{
	if [[ ! -f "$CONF_FILE" ]]; then
		print_error_exit "Config file not found. Generate with -c"
	fi

	if [[ "$AUTO_UPDATE_ENABLED" == "true" ]]; then
		sed -i 's/AUTO_UPDATE_ENABLED=\(\"true\"\|true\)/AUTO_UPDATE_ENABLED="false"/' "$CONF_FILE"
		print_message "JSON auto-updating: ${RED}DISABLED"
	else
		sed -i 's/AUTO_UPDATE_ENABLED=\(\"false\"\|false\)/AUTO_UPDATE_ENABLED="true"/' "$CONF_FILE"
		print_message "JSON auto-updating: ${GREEN}ENABLED"
	fi
}

generate_conf_file()
{
	print_warning "This will overwrite the config file with default values."
	read -rp "${BOLD}Proceed? (y/N): $NC" choice

	if [[ "$choice" != "Y" && "$choice" != "y" ]]; then
		return 0
	fi

	[[ ! -d "$CONF_DIR" ]] && mkdir -p "$CONF_DIR"

	{
		# shellcheck disable=SC2016
		printf 'DEFAULT_DOWNLOAD_DIR="$PWD"\n'
		printf 'AUTO_UPDATE_ENABLED="false"\n'
		printf 'VERIFICATION_ENABLED="true"\n'
		printf 'SPIDER_MODE_ENABLED="false"\n'
	} > "$CONF_FILE"

	print_message "Made config file at: ${GREEN}$CONF_FILE"
}

delete_gpg_key()
{
	dependency_check "gpg"

	if gpg --homedir "$GPG_DIR" --delete-keys "$1" &> /dev/null; then
		print_message "GPG key deletion: ${GREEN}SUCCESS"
	else
		print_message "GPG key deletion: ${RED}FAILED"
	fi
}

import_gpg_key()
{
	dependency_check "gpg"

	[[ ! -d "$GPG_DIR" ]] && mkdir -p "$GPG_DIR"

	gpg_dir_perms="$(stat -c "%a" "$GPG_DIR")"

	[[ "$gpg_dir_perms" != "700" ]] && chmod 700 "$GPG_DIR"

	if gpg --homedir "$GPG_DIR" --import "$1" &> /dev/null; then
		print_message "GPG key import: ${GREEN}SUCCESS"
	else
		print_error "GPG key import: ${RED}FAILED"
		exit 1
	fi
}

list_gpg_keys()
{
	dependency_check "gpg"
	gpg --homedir "$GPG_DIR" --list-keys 2> /dev/null
}

purge_all_data()
{
	print_warning "This will remove ALL stored data at: $DATA_DIR"
	read -rp "${BOLD}Proceed? (y/N): $NC" choice

	if [[ "$choice" == "Y" || "$choice" == "y" ]]; then
		rm -rf "$DATA_DIR"
		print_message "Data deleted successfully."
	else
		print_warning "Data purge canceled."
		exit 1
	fi
}

update_json_file()
{
	for json_url in "${JSON_URLS[@]}"; do
		if wget -P "$JSON_DIR" -q "$json_url"; then
			print_message "Successfully updated the JSON file."
			return 0
		else
			print_warning "Failed to update the JSON file from: ${YELLOW}$json_url"
			print_warning "Trying next mirror..."
		fi
	done

	print_error "Failed to update the JSON file."
	exit 1
}

usage()
{
	cat <<EOF
USAGE
  dl-distro -d <DISTRO|JSON_QUERY> [OPTIONS]

  dl-distro

OPTIONS
  -a                      : Toggle on or off automatic updating of the local
                            JSON file.
  -c                      : Generate a config file with default values.
  -d <DISTRO|JSON_QUERY>  : Specify distribution by its short name
                            (e.g., 'arch') or a JSON path query
                            (e.g., 'arch.latest').
  -D <KEY_ID>             : Delete a stored GPG key using its GPG key id.
  -h                      : Display this help message.
  -i <KEY_FILE>           : Import a GPG key from a key file.
  -l                      : List the stored GPG keys.
  -n                      : Skip GPG, Minisign, or Signify key fetching and
                            verification.
  -p <PATH>               : Download image to specified directory.
  -P                      : Purge ALL the stored data. Includes GPG, Minisign,
                            Signify keys and the JSON file.
  -s                      : Check if the URLs for the chosen image return a 200
                            status, indicating they are valid URLs.
  -u                      : Update the locally stored JSON file.
  -V                      : Print dl-distro's current version.

DISTROS
  alma    gparted  opensuse   solus
  alpine  kali     parrot     tails
  arch    mint     qubes      ubuntu
  debian  nixos    rocky      void
  fedora  openbsd  slackware  whonix

EXAMPLES
  dl-distro
  dl-distro -d arch
  dl-distro -d arch.latest -p ~/Downloads
EOF
}

traverse_json()
{
	traverse_path="$1"

	if jq -e "${traverse_path}.url" "$JSON_FILE" &> /dev/null; then
		IFS='|' read -r url iso_file sig_file sum_file <<< "$(jq -r "[$traverse_path | .url, .iso_file, .sig_file, .sum_file] | join(\"|\")" "$JSON_FILE")"
	else
		[[ "${jq_path_used:-}" = 1 ]] && print_error "Invalid JSON path query." && exit 1

		mapfile -t choices < <(jq -r "$traverse_path | keys | .[]" "$JSON_FILE")

		[[ "${#choices[@]}" -eq 0 ]] && print_error "JSON parsing error." && exit 1

		PS3="${BOLD}Enter your choice (1-${#choices[@]}): $NC"

		select choice in "${choices[@]}"; do
			if [[ -z "$choice" ]]; then
				print_error "Invalid option: ${RED}$REPLY"
				continue
			fi

			traverse_json "$traverse_path.$choice"
			return 0
		done
	fi
}

# TODO: settings
settings()
{
	print_error "Settings still WIP..."
	exit 1
}

main_menu()
{
	mapfile -t sorted_distros < <(printf "%s\n" "${!DISTROS[@]}" | sort)

	options=("${sorted_distros[@]}" "Settings" "Quit")

	PS3="${BOLD}Enter your choice (1-${#options[@]}): $NC"

	select choice in "${options[@]}"; do
		if [[ -z "$choice" ]]; then
			print_error "Invalid option: ${RED}$REPLY"
			continue
		fi

		case "$choice" in
			"Settings")
				settings
				;;
			"Quit") exit 0 ;;
			*)
				distro="${DISTROS["$choice"]}"
				traverse_json ".$distro"
				download_"$distro"
				exit 0
				;;
		esac
	done
}

cli_mode()
{
	if [[ "$DISTRO_OR_JQPATH" == *.* ]]; then
		distro="${DISTRO_OR_JQPATH%%.*}"
		jq_path_used=1
	else
		distro="$DISTRO_OR_JQPATH"
		jq_path_used=0
	fi

	if type download_"$distro" &> /dev/null; then
		traverse_json ".$DISTRO_OR_JQPATH"
		download_"$distro"
	else
		print_error "Invalid distro: $distro"
		exit 1
	fi
}

parse_opts()
{
	cli_mode=0

	while getopts ":acd:D:hi:lnp:PsuV" opt; do
		case "$opt" in
			a) toggle_auto_update; exit 0 ;;
			c) generate_conf_file; exit 0 ;;
			d) DISTRO_OR_JQPATH="$OPTARG"; cli_mode=1 ;;
			D) delete_gpg_key "$OPTARG"; exit 0 ;;
			h) usage; exit 0 ;;
			i) import_gpg_key "$OPTARG"; exit 0 ;;
			l) list_gpg_keys; exit 0 ;;
			n) VERIFICATION_ENABLED="false" ;;
			p) DEFAULT_DOWNLOAD_DIR="$OPTARG" ;;
			P) purge_all_data; exit 0 ;;
			s) SPIDER_MODE_ENABLED="true" ;;
			u) update_json_file; exit 0 ;;
			V) print_version; exit 0 ;;
			\?) print_error "Invalid option -$OPTARG. See dl-distro -h"; exit 1 ;;
			:)
				case "$OPTARG" in
					d) print_error "Option -$OPTARG requires a distro name or JSON path query."; exit 1 ;;
					D) print_error "Option -$OPTARG requires a GPG key id."; exit 1 ;;
					i) print_error "Option -$OPTARG requires a GPG key file path."; exit 1 ;;
					p) print_error "Option -$OPTARG requires a directory path."; exit 1 ;;
					*) print_error "Option -$OPTARG requires an argument."; exit 1 ;;
				esac
				;;
		esac
	done
}

main()
{
	dependency_check "jq" "wget"
	parse_opts "$@"

	[[ "$AUTO_UPDATE_ENABLED" == "true" ]] && update_json_file

	for json_path in "${JSON_PATHS[@]}"; do
		if [[ -f "$json_path" ]]; then
			JSON_FILE="$(realpath -m "$json_path")"
			print_message "Using JSON file: $JSON_FILE"
			print_message "Downloading at: $DEFAULT_DOWNLOAD_DIR"
		fi
	done

	if [[ -z "${JSON_FILE:-}" ]]; then
		print_error "Couldn't find a JSON file. Please use -u"
		exit 1
	fi

	if [[ "$cli_mode" = 0 ]]; then
		main_menu
	else
		cli_mode
	fi
}

main "$@"
