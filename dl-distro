#!/usr/bin/env bash
#
# dl-distro - Bash script for downloading and verifying OS images.
#
# Copyright (C) 2023 bashuser30 <bashuser30 at mailbox dot org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -euo pipefail

print_error_and_exit() {
	printf "[dl-distro] ERROR: %s\n" "$1" >&2
	exit 1
}

print_warning() {
	printf "[dl-distro] WARNING: %s\n" "$1" >&2
}

print_message() {
	printf "[dl-distro] %s\n" "$1"
}

check_dependencies() {
	missing_deps=()

	for cmd in "$@"; do
		command -v "$cmd" &> /dev/null || missing_deps+=("$cmd")
	done

	if [[ "${#missing_deps[@]}" -eq 0 ]]; then
		return 0
	else
		print_error_and_exit "Please install: ${missing_deps[*]}"
	fi
}

wget_file() {
	local url

	for url in "$@"; do
		if ! wget -P "$download_path" -qc --show-progress "$url"; then
			print_error_and_exit "Failed to download: $url"
		fi
	done
}

wget_spider() {
	[[ "$spider_mode_enabled" == "false" ]] && return 0

	expect_mode_enabled="${EXPECT_MODE_ENABLED:-false}"
	spidered_urls_file="/tmp/dl-distro_spidered_urls.txt"

	local url

	for url in "$@"; do
		if [[ "$expect_mode_enabled" == "true" ]]; then
			if grep -qxF "$url" "$spidered_urls_file" 2> /dev/null; then
				continue
			fi
		fi

		sleep 1

		if wget -nvc --spider "$url"; then
			if [[ "$expect_mode_enabled" == "true" ]]; then
				printf "%s\n" "$url" >> "$spidered_urls_file"
			fi
		else
			print_error_and_exit "Spider failed for: $url"
		fi
	done

	exit 0
}

fetch_gpg_key() {
	[[ "$verification_enabled" == "false" ]] && return 0

	check_dependencies "gpg"

	gpg_key="$(jq -r ".gpg_keys.$1" "$json_file")"

	[[ ! -d "$data_dir" ]] && mkdir -p "$data_dir"

	gpg_dir_perms="$(stat -c "%a" "$data_dir")"

	[[ "$gpg_dir_perms" != "700" ]] && chmod 700 "$data_dir"

	if ! gpg --homedir "$data_dir" --list-keys "$gpg_key" &> /dev/null; then

		print_message "Fetching GPG key."

		if ! gpg --homedir "$data_dir" --keyserver hkps://keyserver.ubuntu.com --recv-keys "$gpg_key" &> /dev/null; then
			print_error_and_exit "Failed to fetch GPG key: $gpg_key"
		fi
	fi
}

fetch_minisign_key() {
	[[ "$verification_enabled" == "false" ]] && return 0

	check_dependencies "minisign"

	minisign_key_url="$(jq -r ".minisign_keys.$distro" "$json_file")"
	minisign_key="$(basename "$minisign_key_url")"
	minisign_dir="$data_dir/minisign_keys"

	if [[ ! -f "$minisign_dir/$minisign_key" ]]; then

		print_message "Fetching Minisign key."

		if ! wget -P "$minisign_dir" -q "$minisign_key_url"; then
			print_error_and_exit "Failed to fetch Minisign key from: $minisign_key_url"
		fi
	fi
}

fetch_signify_key() {
	[[ "$verification_enabled" == "false" ]] && return 0

	if [[ -f /etc/os-release ]]; then
		# shellcheck disable=SC1091
		source /etc/os-release
	else
		print_warning "/etc/os-release is missing."
		print_message "This is to determine the package name signify uses."
		print_message "Defaulting to: signify"
	fi

	if [[ "${ID:-}" == "debian" || "${ID_LIKE:-}" =~ debian ]]; then
		signify_name="signify-openbsd"
	else
		signify_name="signify"
	fi

	check_dependencies "$signify_name"

	signify_key_url="$(jq -r ".signify_keys.$distro" "$json_file")"
	signify_key="$(basename "$signify_key_url")"
	signify_dir="$data_dir/signify_keys"

	if [[ ! -f "$signify_dir/$signify_key" ]]; then

		print_message "Fetching Signify key."

		if ! wget -P "$signify_dir" -q "$signify_key_url"; then
			print_error_and_exit "Failed to fetch Signify key from: $signify_key_url"
		fi
	fi
}

verify_gpg_signature() {
	[[ "$verification_enabled" == "false" ]] && return 0

	cd "$download_path" || exit 1

	if gpg --homedir "$data_dir" --verify "$@" &> /dev/null; then
		print_message "GPG verification: SUCCESS"
	else
		rm -f "$iso_file" "$sig_file" "$sum_file"
		print_error_and_exit "GPG verification: FAILED"
	fi
}

verify_minisign_signature() {
	[[ "$verification_enabled" == "false" ]] && return 0

	cd "$download_path" || exit 1

	if minisign -Vp "$minisign_dir/$minisign_key" -x "$sig_file" -m "$sum_file" &> /dev/null; then
		print_message "Minisign verification: SUCCESS"
	else
		rm -f "$sig_file" "$sum_file"
		print_error_and_exit "Minisign verification: FAILED"
	fi
}

verify_signify_signature() {
	[[ "$verification_enabled" == "false" ]] && return 0

	cd "$download_path" || exit 1

	if "$signify_name" -Vp "$signify_dir/$signify_key" -x "$sig_file" -m "$sum_file" &> /dev/null; then
		print_message "Signify verification: SUCCESS"
	else
		rm -f "$sig_file" "$sum_file"
		print_error_and_exit "Signify verification: FAILED"
	fi
}

verify_checksum() {
	cd "$download_path" || exit 1

	sum_algo="$(jq -r ".sum_algos.$distro" "$json_file")"

	if "$sum_algo" -c --ignore-missing "$sum_file" &> /dev/null; then
		rm -f "$sig_file" "$sum_file"
		print_message "$sum_algo verification: SUCCESS"
		print_message "Download and verification successful."
	else
		rm -f "$iso_file" "$sig_file" "$sum_file"
		print_error_and_exit "$sum_algo verification: FAILED"
	fi
}

download_alma() {
	wget_spider "$url"/{"$iso_file","$sig_file"}

	if [[ "$traverse_path" == *"${distro}_8"* ]]; then
		fetch_gpg_key "${distro}_8"
	else
		fetch_gpg_key "${distro}_9"
	fi

	wget_file "$url/$sig_file"
	verify_gpg_signature "$sig_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_alpine() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

download_arch() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

download_debian() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_fedora() {
	wget_spider "$url"/{"$iso_file","$sig_file"}

	if [[ "$traverse_path" == *"astronomy"* ]]; then
		fetch_gpg_key "${distro}_38"
	else
		fetch_gpg_key "${distro}_39"
	fi

	wget_file "$url/$sig_file"
	verify_gpg_signature "$sig_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_gparted() {
	sig_sum_url="$(jq -r ".oddballs.gparted.sig_sum_url" "$json_file")"
	wget_spider "$url/$iso_file" "$sig_sum_url"/{"$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$sig_sum_url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_kali () {
	if [[ "$traverse_path" == *"weekly"* ]]; then
		html_content="$(wget -qO- "$url")"
		current_week_num="$(grep -o 'W[0-9]\+' <<< "$html_content" | sort -r | head -n 1 | cut -c2-)"
		iso_file="${iso_file//\{current_week_num\}/$current_week_num}"

		if ! grep -qF "$iso_file" <<< "$html_content"; then
			print_warning "No new ISO for week: $current_week_num"
			print_message "Downloading previous week."
			(( prev_week_num=current_week_num-1 ))
			iso_file="${iso_file//$current_week_num/$prev_week_num}"
		fi
	fi

	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_mint () {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_openbsd() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_signify_key
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_signify_signature
	wget_file "$url/$iso_file"
	verify_checksum
	IFS='.' read -ra path_parts <<< "$traverse_path"
	architecture="${path_parts[3]}"
	base_name="${iso_file%.*}"
	ext="${iso_file##*.}"
	mv "$iso_file" "${base_name}-${architecture}.${ext}"
}

download_opensuse() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	read -r line < "$sum_file"
	iso_file="${line##* }"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_parrot() {
	wget_spider "$url"/{"$iso_file","$sig_file"}
	fetch_gpg_key "$distro"
	wget_file "$url/$sig_file"
	verify_gpg_signature "$sig_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_qubes() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url/$sum_file"
	verify_gpg_signature "$sum_file"
	wget_file "$url"/{"$sig_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

download_slackware() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

download_solus() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_tails() {
	wget_spider "$url"/{"$iso_file","$sig_file"}
	fetch_gpg_key "$distro"
	wget_file "$url"/{"$sig_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	rm -f "$sig_file"
	print_message "Download and GPG verification successful. Tails does not provide checksum files."
}

download_ubuntu() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}

	if [[ "$traverse_path" == *"trusty"* ]]; then
		fetch_gpg_key "$distro"
		fetch_gpg_key "${distro}_trusty"
	else
		fetch_gpg_key "$distro"
	fi

	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_gpg_signature "$sig_file" "$sum_file"
	wget_file "$url/$iso_file"
	verify_checksum
}

download_void() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}
	fetch_minisign_key
	wget_file "$url"/{"$sig_file","$sum_file"}
	verify_minisign_signature
	wget_file "$url/$iso_file"
	verify_checksum
}

download_whonix() {
	wget_spider "$url"/{"$iso_file","$sig_file","$sum_file"}

	if [[ "$traverse_path" == *"qemu"* ]]; then
		fetch_gpg_key "${distro}_qemu"
	else
		fetch_gpg_key "${distro}_vbox"
	fi

	wget_file "$url"/{"$sig_file","$sum_file","$iso_file"}
	verify_gpg_signature "$sig_file" "$iso_file"
	verify_checksum
}

usage() {
	cat <<EOF
USAGE: dl-distro [OPTIONS] [DISTRO] [PATH]

  -h, --help         Display this usage message
  -a, --auto-fetch   Toggle on/off automatic JSON fetching
  -d, --delete-key   Delete a GPG key: dl-distro -d [KEY_ID]
  -i, --import-key   Import a GPG key: dl-distro -i /path/to/key.asc
  -l, --list-keys    List the stored GPG keys
  -n, --no-verify    Skip key fetching and verification
  -p, --purge-data   Delete ALL stored data
  -s, --spider       Check image availability without downloading
  -u, --update-json  Update the locally stored JSON file

DISTROS
  alma    gparted   parrot     ubuntu
  alpine  kali      qubes      void
  arch    mint      slackware  whonix
  debian  openbsd   solus
  fedora  opensuse  tails

EXAMPLES
  dl-distro arch
  dl-distro arch /run/media/$USER/Ventoy
  dl-distro -n arch
EOF
	exit 0
}

list_gpg_keys() {
	check_dependencies "gpg"

	if gpg --homedir "$data_dir" --list-keys 2> /dev/null; then
		exit 0
	else
		print_message "There are no GPG keys stored."
		exit 0
	fi
}

import_gpg_key() {
	check_dependencies "gpg"

	[[ ! -d "$data_dir" ]] && mkdir -p "$data_dir"

	gpg_dir_perms="$(stat -c "%a" "$data_dir")"

	[[ "$gpg_dir_perms" != "700" ]] && chmod 700 "$data_dir"

	if gpg --homedir "$data_dir" --import "$1" &> /dev/null; then
		print_message "Successfully imported GPG key: $1"
		exit 0
	else
		print_error_and_exit "Failed to import GPG key: $1"
	fi
}

delete_gpg_key() {
	check_dependencies "gpg"

	if gpg --homedir "$data_dir" --delete-keys "$1" &> /dev/null; then
		print_message "Successfully deleted GPG key: $1"
		exit 0
	else
		print_error_and_exit "Failed to delete GPG key: $1"
	fi
}

purge_data() {
	read -rp "[dl-distro] WARNING: Really delete ALL stored data? (y/N): " user_choice >&2

	if [[ "$user_choice" == "Y" || "$user_choice" == "y" ]]; then
		rm -rf "$data_dir"
		print_message "Successfully deleted all data."
		exit 0
	else
		print_message "Data purge cancelled."
		exit 0
	fi
}

traverse_json() {
	traverse_path="$1"

	trap "exit 130" INT

	if jq -e "$traverse_path.url" "$json_file" &> /dev/null; then
		read -r url iso_file sig_file sum_file <<< "$(jq -r "[$traverse_path | .url, .iso_file, .sig_file, .sum_file] | @tsv" "$json_file")"
	else
		mapfile -t options < <(jq -r "$traverse_path | keys | .[]" "$json_file")

		if [[ "${#options[@]}" -eq 0 ]]; then
			print_error_and_exit "No options available or JSON parsing error."
		fi

		num_options="${#options[@]}"

		while true; do
			printf "\n"
			for i in "${!options[@]}"; do
				printf "   %d. %s\n" "$((i+1))" "${options[$i]}"
			done
			printf "\n"

			read -rp "Enter your choice (1-$num_options): " user_choice

			if [[ "$user_choice" =~ ^[0-9]+$ ]] && (( user_choice >= 1 && user_choice <= num_options )); then
				chosen_option="${options[$user_choice-1]}"
				traverse_json "$traverse_path.$chosen_option"
				return 0
			else
				printf "\nInvalid choice. Please choose a number 1 to %s.\n" "$num_options" >&2
			fi
		done
	fi
}

fetch_json() {
	[[ "$auto_fetch_enabled" == "true" ]] && update_json

	json_paths=("${XDG_CONFIG_HOME:-$HOME/.config}/dl-distro/data.json"
	            "$(dirname "$0")/data.json"
	            "$data_dir/json_data/data.json")

	for json_path in "${json_paths[@]}"; do
		if [[ -f "$json_path" ]]; then
			json_file="$(realpath -m "$json_path")"
			return 0
		fi
	done

	update_json
	fetch_json
}

update_json() {
	json_urls=("https://codeberg.org/bashuser30/dl-distro/raw/branch/master/data.json"
	           "https://gitlab.com/bashuser30/dl-distro/-/raw/master/data.json"
	           "https://raw.githubusercontent.com/bashuser30/dl-distro/master/data.json")

	json_dir="$data_dir/json_data"

	[[ ! -d "$json_dir" ]] && mkdir -p "$json_dir"

	cd "$json_dir" || exit 1

	for json_url in "${json_urls[@]}"; do
		if wget -O "data.json" -q "$json_url"; then
			print_message "Successfully downloaded latest JSON file."
			return 0
		else
			print_warning "Failed to download data.json from: $json_url"
			print_message "Trying next mirror..."
		fi
	done

	print_error_and_exit "Failed to update the JSON file."
}

toggle_auto_fetch() {
	config_dir="$(dirname "$config_file")"

	[[ ! -d "$config_dir" ]] && mkdir -p "$config_dir"

	if [[ "$auto_fetch_enabled" == "true" ]]; then
		printf "auto_fetch_enabled=false\n" > "$config_file"
		print_message "Disabled JSON auto-fetching."
	else
		printf "auto_fetch_enabled=true\n" > "$config_file"
		print_message "Enabled JSON auto-fetching."
	fi

	exit 0
}

main() {
	data_dir="${XDG_DATA_HOME:-$HOME/.local/share}/dl-distro"
	config_file="${XDG_CONFIG_HOME:-$HOME/.config}/dl-distro/dl-distro.conf"
	verification_enabled="true"
	spider_mode_enabled="false"
	auto_fetch_enabled="false"

	if [[ -f "$config_file" ]]; then
		# shellcheck disable=SC1090
		source "$config_file"
	fi

	while [[ "$#" -gt 0 ]]; do
		case "$1" in
			-h|--help)
				usage
				;;
			-a|--auto-fetch)
				toggle_auto_fetch
				;;
			-d|--delete-key)
				delete_gpg_key "${2:-}"
				;;
			-i|--import-key)
				import_gpg_key "${2:-}"
				;;
			-l|--list-keys)
				list_gpg_keys
				;;
			-n|--no-verify)
				verification_enabled="false"
				shift
				;;
			-p|--purge-data)
				purge_data
				;;
			-s|--spider)
				spider_mode_enabled="true"
				shift
				;;
			-u|--update-json)
				update_json
				exit 0
				;;
			-*)
				print_error_and_exit "Invalid option: $1"
				;;
			*)
				break
				;;
		esac
	done

	distro="${1:-}"
	download_path="$(realpath -m "${2:-$(pwd)}")"

	[[ -z "$distro" ]] && print_error_and_exit "No distro provided."

	if type download_"$distro" &> /dev/null; then
		check_dependencies "jq" "wget"
		fetch_json
		traverse_json ".$distro"
		download_"$distro"
	else
		print_error_and_exit "Invalid distro: $distro"
	fi
}

main "$@"
