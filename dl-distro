#!/usr/bin/env bash
# https://codeberg.org/codeberge/dl-distro/src/branch/master/README.md

set -euo pipefail

wget_file() {

    for file in "$@"; do
        if ! wget -q --show-progress -c "$url/$file"; then
            echo -e "\nError: Failed to download $file.\n"
            exit 1
        fi
    done

}

fetch_gpg_key() {

    if ! gpg --list-keys "$gpg_key" &> /dev/null; then
        echo -e "\nFetching GPG key: $gpg_key\n"
        if ! gpg --keyserver keyserver.ubuntu.com --recv-keys "$gpg_key"; then
            echo -e "\nError: Failed to fetch GPG key $gpg_key.\n"
            exit 1
        fi
    fi

}

gpg_verify() {

    if ! gpg --verify "$sig_file" "$1"; then
        echo -e "\nError: GPG verification failed.\n"
        rm -f "$iso_file" "$sig_file" "$sum_file"
        exit 1
    fi

}

checksum_verify() {

    if ! "$sum_algo" -c --ignore-missing "$sum_file"; then
        echo -e "\nError: $sum_algo verification failed.\n"
        rm -f "$iso_file" "$sig_file" "$sum_file"
        exit 1
    else
        rm -f "$sig_file" "$sum_file"
        echo -e "\n[dl-distro] Download and verification successful.\n"
        exit 0
    fi

}

handle_download_path() {

    if [[ "$download_path" != "$(pwd)" ]]; then
        mkdir -p "$download_path" && cd "$download_path" || exit 1
    fi

}

# Takes an array, displays it to the user and assigns their choice to a variable
# Usage: selected_architecture="$(get_choice "amd64" "arm64")"
# If the user picks amd64, selected_architecture=amd64
# Automatically assigns the variable if called with a single choice: selected_architecture="$(get_choice "amd64")"
get_choice() {

    options=("$@")
    num_options="${#options[@]}"

    if [[ "$num_options" -eq 1 ]]; then
        printf "%s" "${options[0]}"
        return 0
    fi

    while true; do
        echo >&2

        for i in "${!options[@]}"; do
            printf "   %d. %s\n" "$((i+1))" "${options[$i]}" >&2
        done

        echo >&2

        read -rp "Enter your choice (1-$num_options): " user_choice >&2

        if [[ "$user_choice" -ge 1 && "$user_choice" -le "$num_options" ]]; then
            printf "%s" "${options[$user_choice-1]}"
            return 0
        else
            echo -e "\nInvalid choice. Please choose a number 1 to $num_options." >&2
        fi
    done

}

# Fetches values for specific keys from the JSON file using readarray
# Assigns the values to variables that our downloading and verifying functions can use
# Usage: fetch_and_assign_values "version" "gpg_key" "url" "iso_file" "sig_file" "sum_file" "sum_algo"
fetch_and_assign_values() {

    keys=("$@")

    # Convert the keys array into a comma-separated string
    jq_query="$(printf ".${distro}.%s, " "${keys[@]}")"
    jq_query="${jq_query%, }"  # Remove the trailing comma

    # Fetch values using the jq query string
    readarray -t values < <(jq -r "${jq_query}" "$json_file")

    version="${values[0]}"
    gpg_key="${values[1]}"
    url="${values[2]}"
    iso_file="${values[3]}"
    sig_file="${values[4]}"
    sum_file="${values[5]}"
    sum_algo="${values[6]}"

}

# Replaces placeholders that are present in the JSON file
# {selected_architecture} for example would be replaced with $selected_architecture
# Example: replace_placeholders "url|version|selected_architecture"
# Replaces the version and architecture in the url
replace_placeholders() {

    declare -A replacements=(
        ["version"]="${version:-}"
        ["selected_architecture"]="${selected_architecture:-}"
        ["selected_environment"]="${selected_environment:-}"
        ["selected_image"]="${selected_image:-}"
        ["current_week_num"]="${current_week_num:-}"
        ["ext"]="${ext:-}"
    )

    for var_and_replacements in "$@"; do
        IFS='|' read -ra var_parts <<< "$var_and_replacements"
        var_name="${var_parts[0]}"
        var_value="${!var_name}"

        for replacement_var in "${var_parts[@]:1}"; do
            replacement="${replacements[$replacement_var]}"
            var_value="${var_value//\{$replacement_var\}/$replacement}"
        done

        printf -v "$var_name" "%s" "$var_value"
    done

}

download_arch() {

    fetch_and_assign_values "version" "gpg_key" "url" "iso_file" "sig_file" "sum_file" "sum_algo"
    replace_placeholders "url|version" "iso_file|version" "sig_file|version"
    wget_spider
    handle_download_path
    fetch_gpg_key
    wget_file "$sig_file" "$sum_file" "$iso_file"
    gpg_verify "$iso_file"
    checksum_verify

}

download_debian() {

    installer_type="$(get_choice "Net Installer" "Live Installer")"

    case "$installer_type" in

        "Net Installer")

            selected_architecture="$(get_choice "amd64" "arm64" "armel" "armhf" "i386" "mips64el" "mipsel" "ppc64el" "s390x")"
            fetch_and_assign_values "version" "gpg_key" "net_installer.url" "net_installer.iso_file" "sig_file" "sum_file" "sum_algo"
            replace_placeholders "url|selected_architecture" "iso_file|version|selected_architecture" ;;

        "Live Installer")

            selected_environment="$(get_choice "cinnamon" "gnome" "kde" "lxde" "lxqt" "mate" "standard" "xfce")"
            fetch_and_assign_values "version" "gpg_key" "live_installer.url" "live_installer.iso_file" "sig_file" "sum_file" "sum_algo"
            replace_placeholders "iso_file|version|selected_environment" ;;
    esac

    wget_spider
    handle_download_path
    fetch_gpg_key
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"
    wget_file "$iso_file"
    checksum_verify

}

download_kali() {

    installer_type="$(get_choice "Kali" "Kali Weekly")"
    selected_image="$(get_choice "live" "qemu" "virtualbox" "vmware" "hyperv" "installer" "installer-netinst" "installer-purple")"

    case "$selected_image" in

        "live"|"installer"|"installer-netinst") selected_architecture="$(get_choice "amd64" "arm64" "i386")"; ext="iso" ;;
        "installer-purple")                     selected_architecture="$(get_choice "amd64")";                ext="iso" ;;
        "hyperv")                               selected_architecture="$(get_choice "amd64")";                ext="7z" ;;
        *)
           if [[ "$installer_type" == "Kali Weekly" ]]; then
               selected_architecture="$(get_choice "amd64")"
           else
               selected_architecture="$(get_choice "amd64" "i386")"
           fi
           ext="7z" ;;
    esac

    case "$installer_type" in

        "Kali")

            fetch_and_assign_values "version" "gpg_key" "standard.url" "standard.iso_file" "sig_file" "sum_file" "sum_algo"

            # Patches version from example: 2023.3 > 2023.3a for certain images only
            # Comment out the type_to_patch array when there aren't any patches
            declare -A type_to_patch
            #type_to_patch=( ["hyperv"]="a" ["installer"]="a" ["installer-netinst"]="a" ["installer-purple"]="a" )

            if [[ -v type_to_patch["$selected_image"] ]]; then
                patch="${type_to_patch[$selected_image]}"
                version+="$patch"
            fi

            replace_placeholders "iso_file|version|selected_image|selected_architecture|ext" ;;

        "Kali Weekly")

            fetch_and_assign_values "version" "gpg_key" "weekly.url" "weekly.iso_file" "sig_file" "sum_file" "sum_algo"

            # wget the weekly url and grab the current weeks number, this ensures no timezone issues
            # grep the html_content for the iso_file, fall back to previous week if it doesn't exist
            html_content="$(wget -qO- "$url")"
            current_week_num="$(echo "$html_content" | grep -o 'W[0-9]\+' | sort -r | head -n1 | cut -c2-)"

            replace_placeholders "iso_file|current_week_num|selected_image|selected_architecture|ext"

            if ! echo "$html_content" | grep -q "$iso_file"; then
                echo -e "\nNo new ISO for week: $current_week_num. Downloading previous week.\n"
                (( prev_week_num=current_week_num-1 ))
                iso_file="${iso_file//$current_week_num/$prev_week_num}"
            fi ;;
    esac

    wget_spider
    handle_download_path
    fetch_gpg_key
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"
    wget_file "$iso_file"
    checksum_verify

}

download_mint() {

    installer_type="$(get_choice "Mint" "Mint Debian Edition")"

    case "$installer_type" in

        "Mint")

            selected_environment="$(get_choice "cinnamon" "mate" "xfce")"
            fetch_and_assign_values "standard.version" "gpg_key" "standard.url" "standard.iso_file" "sig_file" "sum_file" "sum_algo"
            replace_placeholders "url|version" "iso_file|version|selected_environment" ;;

        "Mint Debian Edition")

            fetch_and_assign_values "debian_edition.version" "gpg_key" "debian_edition.url" "debian_edition.iso_file" "sig_file" "sum_file" "sum_algo"
            replace_placeholders "iso_file|version" ;;
    esac

    wget_spider
    handle_download_path
    fetch_gpg_key
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"
    wget_file "$iso_file"
    checksum_verify

}

download_ubuntu() {

    installer_type="$(get_choice "Ubuntu" "Ubuntu LTS")"
    selected_image="$(get_choice "desktop" "live-server")"

    case "$installer_type" in

        "Ubuntu")

            fetch_and_assign_values "standard.version" "gpg_key" "url" "iso_file" "sig_file" "sum_file" "sum_algo" ;;

        "Ubuntu LTS")

            fetch_and_assign_values "lts.version" "gpg_key" "url" "iso_file" "sig_file" "sum_file" "sum_algo" ;;
    esac

    replace_placeholders "url|version" "iso_file|version|selected_image"

    wget_spider
    handle_download_path
    fetch_gpg_key
    wget_file "$sig_file" "$sum_file"
    gpg_verify "$sum_file"
    wget_file "$iso_file"
    checksum_verify

}

check_dependencies() {

    missing_deps=()

    for cmd in wget gpg jq; do
        command -v "$cmd" &> /dev/null || missing_deps+=("$cmd")
    done

    if [[ "${#missing_deps[@]}" -gt 0 ]]; then
        echo -e "\nPlease install: ${missing_deps[*]}.\n"
        exit 1
    else
        return 0
    fi

}

# This function is used with an external Expect script I made
# It checks the sig and sum file for each distro's URL(s) and then every ISO combination possible
# Helps a lot with detecting version and file name changes if I happen to miss an announcement
wget_spider() {

    if [[ "$download_path" != "--spider" ]]; then
        return
    fi

    tracked_file="/tmp/dl-distro_tracked.txt"
    tracked_string="${distro}_${installer_type:-}_checked"

    spider_file() {
        local file="$1"
        if ! wget -nv -c --spider "$url/$file"; then
            echo -e "\nError: Failed to download $file.\n"
            exit 1
        fi
    }

    if ! grep -q "$tracked_string" "$tracked_file" 2>/dev/null; then
        spider_file "$sig_file"
        spider_file "$sum_file"
        echo "$tracked_string" >> "$tracked_file"
    fi

    spider_file "$iso_file"
    exit 0

}

usage() {

    cat <<EOF

USAGE:
    dl-distro [distro] [path]

DISTROS:
    arch
    debian
    kali
    mint
    ubuntu

EXAMPLES:
    dl-distro arch
    dl-distro arch /run/media/$USER/Ventoy

EOF

}

dl_distro() {

    distro="${1:-help}"
    download_path="${2:-$(pwd)}"

    case "$distro" in
        -h|--help|help) usage; exit 0 ;;
    esac

    json_file="$(for path in \
                     "$HOME/.config/dl-distro/distro_data.json" \
                     "/usr/share/dl-distro/distro_data.json" \
                     "$(dirname "$0")/distro_data.json"; \
                 do
                     [[ -f "$path" ]] && echo "$path" && break;
                 done || { echo -e "\nError: distro_data.json not found in any of the expected locations.\n" >&2;
                           exit 1;
                 })"

    case "$distro" in
        "arch") download_arch ;;
        "debian") download_debian ;;
        "kali") download_kali ;;
        "mint") download_mint ;;
        "ubuntu") download_ubuntu ;;
        *) echo -e "\nError: Please use -h or --help for usage and supported distros.\n"; exit 1 ;;
    esac

}

check_dependencies
dl_distro "$@"
